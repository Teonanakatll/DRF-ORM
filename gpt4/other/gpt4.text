задание 1 - для наглядности результата изменил строку
test1 = BookG.objects.filter(title__icontains='Куба').order_by('title')
SELECT "gpt4_bookg"."id", "gpt4_bookg"."title", "gpt4_bookg"."author_id" FROM "gpt4_bookg" WHERE UPPER("gpt4_bookg"."title"::text) LIKE UPPER(%Куба%)
ORDER BY "gpt4_bookg"."title" ASC

задание 2 - для наглядности результата изменил строку
 test2 = Author.objects.values('name').annotate(my_books=Count('books')).filter(my_books__gt=0).order_by('name')
SELECT "gpt4_author"."name", COUNT("gpt4_bookg"."id") AS "my_books" FROM "gpt4_author" LEFT OUTER JOIN "gpt4_bookg" ON ("gpt4_author"."id" =
"gpt4_bookg"."author_id") GROUP BY "gpt4_author"."name" HAVING COUNT("gpt4_bookg"."id") > 0 ORDER BY "gpt4_author"."name" ASC

задание 3 - для наглядности результата вывел и сам рейтинг
 test3 = Review.objects.values('book__title', 'rating').filter(rating__gt=3)
SELECT "gpt4_bookg"."title", "gpt4_review"."rating" FROM "gpt4_review" INNER JOIN "gpt4_bookg" ON ("gpt4_review"."book_id" = "gpt4_bookg"."id") WHERE
"gpt4_review"."rating" > 3

задание 4
test4 = BookG.objects.values('title').filter(reviews__isnull=True)
SELECT "gpt4_bookg"."title" FROM "gpt4_bookg" LEFT OUTER JOIN "gpt4_review" ON ("gpt4_bookg"."id" = "gpt4_review"."book_id") WHERE "gpt4_review"."id" IS
NULL

задание 5
 test5 = BookG.objects.annotate(reviews_count=Count('reviews')).order_by('-reviews_count')
SELECT "gpt4_bookg"."id", "gpt4_bookg"."title", "gpt4_bookg"."author_id", COUNT("gpt4_review"."id") AS "reviews_count" FROM "gpt4_bookg" LEFT OUTER JOIN
"gpt4_review" ON ("gpt4_bookg"."id" = "gpt4_review"."book_id") GROUP BY "gpt4_bookg"."id" ORDER BY 4 DESC

задание 1
test1 = BookG.objects.filter(title__icontains='Куба').order_by('author__name')
SELECT "gpt4_bookg"."id", "gpt4_bookg"."title", "gpt4_bookg"."author_id" FROM "gpt4_bookg" INNER JOIN "gpt4_author" ON ("gpt4_bookg"."author_id" =
"gpt4_author"."id") WHERE UPPER("gpt4_bookg"."title"::text) LIKE UPPER(%Куба%) ORDER BY "gpt4_author"."name" ASC

задание 2
test2 = Author.objects.annotate(num_books=Count('books')).filter(num_books__gt=2).order_by('num_books')
SELECT "gpt4_author"."id", "gpt4_author"."name", COUNT("gpt4_bookg"."id") AS "num_books" FROM "gpt4_author" LEFT OUTER JOIN "gpt4_bookg" ON
("gpt4_author"."id" = "gpt4_bookg"."author_id") GROUP BY "gpt4_author"."id" HAVING COUNT("gpt4_bookg"."id") > 2 ORDER BY 3 ASC

задание 3
test3 = Review.objects.filter(rating__gt=4).order_by('book', 'rating')
SELECT "gpt4_review"."id", "gpt4_review"."content", "gpt4_review"."book_id", "gpt4_review"."rating" FROM "gpt4_review" WHERE "gpt4_review"."rating" > 4
ORDER BY "gpt4_review"."book_id" ASC, "gpt4_review"."rating" ASC

задание 4
test4 = BookG.objects.filter(reviews__isnull=True).order_by('title')
SELECT "gpt4_bookg"."id", "gpt4_bookg"."title", "gpt4_bookg"."author_id" FROM "gpt4_bookg" LEFT OUTER JOIN "gpt4_review" ON ("gpt4_bookg"."id" =
"gpt4_review"."book_id") WHERE "gpt4_review"."id" IS NULL ORDER BY "gpt4_bookg"."title" ASC

задание 5
test5 = BookG.objects.annotate(num_reviews=Count('reviews')).order_by('-num_reviews')
SELECT "gpt4_bookg"."id", "gpt4_bookg"."title", "gpt4_bookg"."author_id", COUNT("gpt4_review"."id") AS "num_reviews" FROM "gpt4_bookg" LEFT OUTER JOIN
"gpt4_review" ON ("gpt4_bookg"."id" = "gpt4_review"."book_id") GROUP BY "gpt4_bookg"."id" ORDER BY 4 DESC

age = randint(30, 40)

genre = [
  ['Фантастика (Science Fiction)', 'Книги о будущем, технологиях, космических путешествиях, роботах, искусственном интеллекте и альтернативных реальностях.'],
  ['Фэнтези (Fantasy)', 'Произведения с элементами магии, вымышленных миров, мифических существ, волшебников и эпических сражений.'],
  ['Детектив (Detective)', 'Истории о расследованиях преступлений, тайнах и разгадках загадочных происшествий.'],
  ['Триллер (Thriller)', 'Захватывающие сюжеты с элементами напряжения, опасности и неожиданными поворотами.'],
  ['Романтика (Romance)', 'Книги, посвященные любовным отношениям, романтическим переживаниям и личным драмам.'],
  ['Приключения (Adventure)', 'Истории о путешествиях, смелых героях, поисках сокровищ и преодолении опасностей.'],
  ['Исторический роман (Historical Fiction)', 'Произведения, действие которых разворачивается в определённую эпоху, часто с реальными историческими событиями.'],
  ['Биография/Мемуары (Biography/Memoir)', 'Литература, описывающая реальную жизнь известных людей или личный опыт автора.'],
  ['Ужасы (Horror)', 'Книги, которые вызывают страх, напряжение и тревогу через сверхъестественные или психологические элементы.'],
  ['Научно-популярная (Non-fiction/Popular Science)', 'Книги, посвященные объяснению науки, технологий, истории и других областей знаний.'],
  ['Юмор (Comedy)', 'Легкие и забавные произведения, наполненные сатирой, шутками и комическими ситуациями.'],
  ['Психологическая драма (Psychological Fiction)', 'Истории, которые исследуют внутренний мир героев, их эмоции, переживания и конфликты.'],
]

authors_biographies = [
    "Джоан Роулинг — британская писательница, наиболее известная благодаря серии книг о Гарри Поттере. До успеха она работала секретарем и преподавателем. Первую книгу написала, переживая тяжелые времена, вдохновившись детскими воспоминаниями.",
    "Стивен Кинг — американский писатель, мастер ужасов и триллеров. Родился в Портленде, штат Мэн. Его путь к успеху начался с рассказов, опубликованных в журналах, а затем с книги «Кэрри», которая принесла ему мировую славу.",
    "Эрих Мария Ремарк — немецкий писатель, участник Первой мировой войны. Его опыт на фронте стал основой для знаменитого романа «На Западном фронте без перемен». Ремарк эмигрировал из Германии из-за своих антивоенных взглядов.",
    "Джейн Остин — английская писательница, чьи работы о любви и социальных нравах стали классикой. Она родилась в 1775 году и вела скромную жизнь в сельской местности. Её романы отличает тонкая сатира и яркие персонажи."
]

pages = randint(30, 200)

: def check_pr(book, pr):
    ...:     if BookGenre.objects.filter(book=book, priority=pr).exists():
    ...:         return 2
    ...:     return 1


 for book in books:
    ...:     while book.genres.all().count() < 3:
    ...:             genre = choice(genres)
    ...:             book_genre, created = BookGenre.objects.get_or_create(book=book, genre=genre, priority=check_pr(book, 1))
    ...:             if created:
    ...:                 cons(f'Добавлен жанр "{genre.name}" к книге "{book.title}"')
    ...:             else:
    ...:                 cons(f'Жанр "{genre.name}" уже существует для книги "{book.title}"')


In [43]: for i in reviews:
    ...:     rand = randint(0, 4)
    ...:     anon = False
    ...:     if rand == 4:
    ...:         anon = True
    ...:     i.is_anonymous = anon
    ...:     i.save()
    ...:     cons(i.is_anonymous, 'red')


In [70]: for i in reviews:
    ...:     now = datetime.now()
    ...:     time.sleep(randint(2, 10))
    ...:     i.created_at = now
    ...:     i.save()
    ...:     cons(i.created_at)

задание 1
authors = Author.objects.filter(books__pages__gt='100').distinct()
SELECT DISTINCT "gpt4_author"."id", "gpt4_author"."name", "gpt4_author"."age" FROM "gpt4_author" INNER JOIN "gpt4_bookg" ON ("gpt4_author"."id" =
"gpt4_bookg"."author_id") WHERE "gpt4_bookg"."pages" > 100

задание 2
books = BookG.objects.annotate(avg_rating=Avg('reviews__rating')).order_by('-avg_rating')
SELECT "gpt4_bookg"."id", "gpt4_bookg"."title", "gpt4_bookg"."author_id", "gpt4_bookg"."pages", AVG("gpt4_review"."rating") AS "avg_rating" FROM
"gpt4_bookg" LEFT OUTER JOIN "gpt4_review" ON ("gpt4_bookg"."id" = "gpt4_review"."book_id") GROUP BY "gpt4_bookg"."id" ORDER BY 5 DESC

задание 3
books = BookG.objects.filter(genres__gt=2).distinct()
SELECT DISTINCT "gpt4_bookg"."id", "gpt4_bookg"."title", "gpt4_bookg"."author_id", "gpt4_bookg"."pages" FROM "gpt4_bookg" INNER JOIN "gpt4_bookgenre" ON
("gpt4_bookg"."id" = "gpt4_bookgenre"."book_id") WHERE "gpt4_bookgenre"."genre_id" > 2

задание 4
books = BookG.objects.filter(genres__name__contains='Фантастика', reviews__rating__gt=3).distinct()
SELECT DISTINCT "gpt4_bookg"."id", "gpt4_bookg"."title", "gpt4_bookg"."author_id", "gpt4_bookg"."pages" FROM "gpt4_bookg" INNER JOIN "gpt4_bookgenre" ON
("gpt4_bookg"."id" = "gpt4_bookgenre"."book_id") INNER JOIN "gpt4_genre" ON ("gpt4_bookgenre"."genre_id" = "gpt4_genre"."id") INNER JOIN "gpt4_review" ON
("gpt4_bookg"."id" = "gpt4_review"."book_id") WHERE ("gpt4_genre"."name"::text LIKE %Фантастика% AND "gpt4_review"."rating" > 3)

задание 5
book = BookG.objects.all()[0]
bookgenre = book.bookgenre_set.first()
bookgenre.priority += 1
bookgenre.save()


задание 6
с датами я вообще не умею работать

задание 7
genres = Genre.objects.annotate(count_books=Count('books'))
SELECT "gpt4_genre"."id", "gpt4_genre"."name", "gpt4_genre"."description", COUNT("gpt4_bookgenre"."book_id") AS "count_books" FROM "gpt4_genre" LEFT OUTER
JOIN "gpt4_bookgenre" ON ("gpt4_genre"."id" = "gpt4_bookgenre"."genre_id") GROUP BY "gpt4_genre"."id"

задание 8
непойму как сделать, ведь нужно одновременно и фильтровать и делать анотацию...


задание 1
authors = Author.objects.annotate(count_revs=Count('books__reviews'))

задание 2
books = BookG.objects.filter(reviews__rating__gt=4).distinct()

задание 3
genres = Genre.objects.annotate(count_bs=Count('books'))

задание 4
books = BookG.objects.filter(genres__isnull=True)

задание 5
bk = BookG.objects.order_by('-pages').first()

задание 6
bks = BookG.objects.annotate(av_rate=Avg('reviews__rating'))

задание 7
bks = BookG.objects.filter(author__name__icontains='Че Гевара', genres__name__icontains='Фантастика')
bks2 = BookG.objects.filter(Q(author__name__icontains='Че Гевара') & Q(genres__name__contains='Фантастика'))

задание 8
books = BookG.objects.all().order_by('pages', 'date_create')
у нас такого поля нет!

задание 9
books = BookG.objects.filter(reviews__rating__gt=3).update(Case(When(author='Иван', then=Value('черновик'))))
этого поля тоже нет, предпологаю что запрос будет такой

задание 10
books = BookG.objects.filter(reviews__isnull=True)


задание 1
authors = Author.objects.filter(Q(books__pages__gt=250) & Q(books__reviews__isnull=False)).distinct()

задание 2
bkk = BookG.objects.filter(genres__gt=1).annotate(average_rate=Avg('reviews__rating')).filter(average_rate__gt=3)
нижний вариант сделал для тренировки считаю верхний вариант лучше так как сразу сузил диапазон анотируемых книг а не выполнил аннотацию ко всем, ведь их может быть 10000)
bkk = BookG.objects.annotate(average_rate=Avg('reviews__rating')).filter(Q(genres__gt=1) & Q(average_rate__gt=3))

задание 3
bks = BookG.objects.annotate(count_reviews=Count('reviews')).filter(count_reviews__isnull=True)

задание 4
Author.objects.annotate(all_books=Count('books')).filter(Q(all_books=1) & Q(books__title__icontains='Путешествие'))

задание 5
BookG.objects.filter(Q(genres__name__contains='Детектив') & Q(reviews__isnull=True)).distinct()

задание 6
gen = Genre.objects.filter(books__pages__lt=100).distinct()

задание 7
BookG.objects.annotate(count_reviews=Count('reviews', filter=Q(reviews__rating__lt=3))).order_by('-count_reviews')

задание 8
Author.objects.filter(books__reviews__isnull=False).distinct()

задание 9
BookG.objects.filter(pages__gt=500).annotate(avg_review_rate=Avg('reviews__rating')).order_by('-avg_review_rate')

задание 10
в этом запросе я не уверен незнаю как точно в запросе обратившись через автора выбрать именно эти книги а потом отфильтровать их по рейтингу
Author.objects.filter(Q(books__genres__isnull=True) & Q(books__reviews__rating__gt=4))
тут начало правильное но потом фильтр может сработать на разных книгах
authors = Author.objects.filter(books__reviews__isnull=True).filter(Q(books__genres__isnull=True) & Q(books__reviews__rating__gt=4))
незнаю как бы я не фильтровал мне нужно както обратиться к одной книге... напрашивается отфильтровать с испльзованием чегото вроде when(Case())... я незнаю))



111


111
111
111
111


111
111
111


111
Задание 1
author = Author.objects.filter(Q(books__pages__gt=300) & Q(books__reviews__rate__gt=4)).distinct()


Задание 2
genres = Genre.objects.filter(Q(books__reviews__rating__gt=3) & Q(books__pages__lt=100)).distinct()

Задание 3
one_year_ago = timezone.now() - timedelta(days=365)
books = BookG.objects.filter(Q(date_create__lt=one_year_ago) & Q(reviews__isnull=True))

Задание 4
five_year_ago = timezone.now() - timedelta(days=365*5)
author = Author.objects.filter(Q(books__date_create__lt=five_year_ago) & Q(books__pages__gt=500))


Задание 5
books = BookG.objects.annotate(av_rate=Avg('reviews__rating'), book_genres=Count('genres')).filter(Q(av_rate__lt=4) & Q(book_genres__gt=1))

Задание 6
av = Author.objects.filter(Q(books__genres__isnull=True) & Q(books__reviews__rating__gt=3)).distinct()

Задание 7
 bs = BookG.objects.annotate(count_rev=Count('reviews', filter=Q(reviews__rating__lt=2))).filter(count_rev__gt=2).distinct()

Задание 8
 genres = Genre.objects.filter(Q(books__pages__gt=400) & Q(books__reviews__rating=5)).distinct()

Задание 9
authors = Author.objects.exclude(Q(books__reviews__rating__lt=2)).filter(books__pages__gt=300)

Задание 10
books = BookG.objects.filter(Q(reviews__isnull=False)).distinct().annotate(max_rate=Max('reviews__rating')).exclude(max_rate__gt=3)


задание 1
Найди авторов, у которых есть книги с рейтингом обзора больше 4 и страницами больше 300.
Author.objects.filter(books__reviews__rating__gt=4, books__pages__gt=300).distinct()

задание 2
Найди книги, которые имеют рейтинг в отзывах больше 3, имеют жанр "Детектив" и были созданы более 2 лет назад.
from dateutil.relativedelta import relativedelta
from django.utils import timezone
two_year = timezone.now() - relativedelta(years=2)
BookG.objects.filter(genres__name__contains='Детектив', reviews__rating__gt=3, created_at__gt=two_year).distinct()

задание 3
Найди жанры, в которых есть хотя бы одна книга с отзывами, где рейтинг меньше 2 и книга имеет меньше 200 страниц.
Genre.objects.filter(books__reviews__rating__lt=2, books__pages__lt=200).distinct()

задание 4
Выведи авторов, у которых есть книги, не относящиеся к жанрам, но с рейтингом отзывов выше 4.
Author.objects.filter(books__genres__isnull=True, books__reviews__gt=4).distinct()

задание 5
Найди книги, у которых хотя бы один отзыв с рейтингом меньше 3 и книга относится к жанрам, имеющим более 3 книг.
- я незнаю как сделать один запросс както нужно отдельно подсчитать количество книг к каждому жанру.. могу в два запроса
genres_more_3_books = Genre.objects.values('name').annotate(all_books=Count('books')).filter(all_books__gt=3)
BookG.objects.filter(reviews__rating__lt=3, genres__in=genres_more_3_books).distinct()


задание 6
Найди книги, которые имеют отзывы с рейтингом больше 4 и страниц больше 500, но у которых нет жанра.
BookG.objects.filter(genres__isnull=True, reviews__rating__gt=4, pages__gt=500)

задание 7
Выведи жанры, которые связаны с книгами, в которых хотя бы один отзыв имеет рейтинг ниже 3 и книга была опубликована в прошлом году.
one_year = timezone.now() - relativedelta(years=1)
Genre.objects.filter(books__reviews__rating__lt=3, books__created_at__gt=one_year).distinct()
если нужна привязка не к отрезку год а к календарному году
Genre.objects.filter(books__reviews__rating__lt=3, books__created_at__year__lt=2024).distinct()

задание 8
Найди авторов, чьи книги не имеют жанров, но в которых есть отзывы с рейтингом больше 4.
Author.objects.filter(books__genres__isnull=True, books__reviews__rating__gt=4).distinct()

задание 9
Найди книги с рейтингом в отзывах меньше 2, страницами больше 100, где жанры не указаны.
BookG.objects.filter(reviews__rating__lt=2, pages__gt=100, genres__isnull=True).distinct()

задание 10
Выведи авторов, у которых есть книги с более чем 3 жанрами и рейтинг в отзывах которых выше 3.
Author.objects.annotate(count_genres=Count('books__genres')).filter(count__genres__gt=3, books__reviews__rating__gt=3)


задание 1
Используя Case и When, найдите книги, у которых рейтинг в отзывах выше 4, и добавьте новое поле с названием
"Рейтинг_отличный", которое будет иметь значение "Да", если рейтинг больше 4, и "Нет", если меньше или равен 4.
BookG.objects.annotate(Рейтинг_отличный=Case(When(reviews__rating__gt=4, then=Value('Да')), When(reviews__rating__lte=4, then=Value('Нет')), output_field=CharField()))

задание 2
Найдите авторов, у которых книги были созданы в 2022 году и имеют более 300 страниц. Примените Case и When для создания
нового поля "Долгий_путь", которое будет равно "Да", если книга больше 500 страниц, и "Нет", если меньше.
Author.objects.values('name').filter(books__created_at__year=2022, books__pages__gt=300).annotate(Долгий_путь=Case(When(books__pages__gt=500, then=Value('Да')), When(books__pages__lt=500, then=Value('Нет')), output_field=CharField()))
 в вопросе стоит найти автором но анотировать книги, я просил задания без селект\префетч релейтед а тут кажется он...
 потому что если я пробую просто анотировать поле и применять фильтры к обратной связи ForeignKey а в связанных моделях
 есть поля и больше 300 и меньше и поэтому всегда выдаёт результат нет...

задание 3
Используя Q и фильтры, найдите книги, которые имеют рейтинг в отзывах больше 3 или страницы больше 400. Используйте комбинацию условий с Q.
BookG.objects.filter(Q(reviews__rating__gt=3) | Q(pages__gt=400)).distinct()

задание 4
Используя агрегацию, найдите жанры, в которых средний рейтинг по отзывам выше 4, а количество книг больше 5.
Genre.objects.annotate(avg_rate=Avg('books__reviews__rating'), count_books=Count('books')).filter(avg_rate__gt=4, count_books__gt=5)

задание 5
Используя агрегации и фильтрацию через F, найдите книги, в которых количество страниц больше, чем рейтинг в отзывах
 в этом моменте не понятно чем максимальный\средний\сумма рейтинг? предположу что сумма рейтингов
BookG.objects.annotate(sum_rate=Sum('reviews__rating')).filter(sum_rate__lt=F('pages'))

задание 6
Найдите авторов, у которых есть книги, созданные в 2019 году или позднее, и количество отзывов на книгу больше 10. Используйте агрегации для подсчёта количества отзывов
Author.objects.annotate(all_rev=Count('books__reviews')).filter(books__created_at__year__gt=2019, all_rev__gt=10).distinct()

задание 7
Используя Case и When, создайте поле, которое будет определять, является ли книга "популярной" (если средний рейтинг
 больше 4 и количество отзывов больше 20), или "непопулярной".
BookG.objects.annotate(avg_rating=Avg('reviews__rating'), count_reviews=Count('reviews'), popular=Case(When(Q(avg_rating__gt=4) & Q(count_reviews__gt=20), then=Value('популярная')), default=Value('непопулярная'), output_field=CharField()))

задание 8
Найдите книги, которые были созданы в определённом временном диапазоне (например, с 2020 по 2022) и имеют рейтинг отзыва
 больше 3. Используйте фильтрацию по датам и условию рейтинга.
BookG.objects.filter(created_at__year__range=[2020, 2022], reviews__rating__gt=3)

задание 9
Используя Q, найдите авторов, у которых есть книги с рейтингом меньше 2 и страницами больше 100.
Author.objects.filter(Q(books__reviews__rating__lt=2) & Q(books__pages__gt=100)).distinct()

задание 10
Используя F и агрегацию, найдите жанры, где количество книг с более чем 500 страницами превышает 3.
в голову приходит только как с помощю Q решить
Genre.objects.annotate(book_500=Count('books', filter=Q(books__pages__gt=500))).filter(Q(book_500__gt=3))

задание 11
Используя Case и When, добавьте в выборку книги, где новый столбец "Рейтинг_книги" будет равен 1, если рейтинг книги
 выше 4, и 0 в противном случае
тут тоже непонятно какой рейтинг суммарный\средний\максимальный? предположим что средний
BookG.objects.annotate(avg_rating=Avg('reviews__rating'), Рейтинг_книги=Case(When(avg_rating__gt=4,then=Value(1)), default=Value(0), output_field=IntegerField()))

задание 12
Найдите книги, у которых количество страниц больше 400 и они были созданы в течение последнего года. Используйте
 фильтрацию по датам и количеству страниц.
one_year = timezone.now() - relativedelta(years=1)
BookG.objects.filter(pages__gt=400, created_at__gt=one_year)

задание 13
Найдите авторов, чьи книги имеют хотя бы один отзыв с рейтингом выше 4, а также они создали книги в прошлом году.
Используйте фильтрацию по датам и рейтингу отзывов.
Author.objects.filter(books__reviews__rating__gt=4, books__created_at__year__lt=2024).distinct()

задание 14
Используя Case и When, добавьте новое поле "Возраст_автора", которое будет вычисляться как разница между текущей датой
и годом рождения автора, и отобразите только тех, у кого возраст больше 30 лет.
date_now = timezone.now()
authors = Author.objects.annotate(
    age=ExpressionWrapper(
        (date_now.year - F('birthday__year')) -
        ((date_now.month, date_now.day) < (F('birthday__month'), F('birthday__day'))),
        output_field=fields.IntegerField()
    )
)

задание 15
Найдите книги, которые были опубликованы в течение определённого периода времени (например, с января по май) и имеют
 менее 100 страниц. Используйте фильтрацию по датам и количеству страниц.
BookG.objects.filter(pages__lt=100, created_at__year=2024, created_at__month__range=[1,5])


Задача 1
Добавь к книгам поле Popularity с помощью Case и When:

Значение "High", если средний рейтинг выше 4 и количество отзывов больше 50.
"Medium", если рейтинг от 3 до 4 и отзывов от 20 до 50.
"Low" в остальных случаях.
books = BookG.objects.annotate(avg_rate=Avg('reviews__rating'), count_revs=Count('reviews'), Popularity=Case(When(avg_rate__gt=4, count_revs__gt=
    ...: 50, then=Value('High')), When(avg_rate__range=[3, 4], count_revs__range=[20, 50], then=Value('Medium')), default=Value('Low'), output_field=Cha
    ...: rField()))

Задача 2
Найди авторов, у которых все книги имеют рейтинг выше среднего рейтинга всех их книг, но ниже среднего рейтинга всех
книг всех авторов.
glob_avg_rating = BookG.objects.aggregate(avg_all=Avg('reviews__rating'))['avg_all']


КОРОЧЕ Я БОЛЬШЕ ЧАСА ДУМАЛ НО ТАК И НЕ СМОГ РЕШИТЬ, ПОСМОТИ КАК ЕЁ РЕШИЛ ТЫ, я просил без сабквери, ты сам не смог решить
её в один запросс и притом консоль даже не хочет выводить резутьтат твоего решения...

# Сначала вычислим средний рейтинг всех книг всех авторов
global_avg_rating = Book.objects.aggregate(global_avg=Avg('reviews__rating'))['global_avg']

# Теперь сделаем основной запрос, где каждый автор будет сравнивать рейтинги своих книг
authors = Author.objects.annotate(
    avg_rate=Avg('books__reviews__rating'),  # Средний рейтинг всех книг автора
    all_books_above_avg=Count(
        'books',
        filter=Q(books__reviews__rating__gt=F('avg_rate'))  # Книги с рейтингом выше среднего этого автора
    ),
    all_books_below_global_avg=Count(
        'books',
        filter=Q(books__reviews__rating__lt=global_avg_rating)  # Книги с рейтингом ниже глобального среднего
    ),
    total_books=Count('books')  # Общее количество книг автора
).filter(
    all_books_above_avg=F('total_books'),  # У автора все книги должны иметь рейтинг выше его среднего
    all_books_below_global_avg=F('total_books')  # У автора все книги должны иметь рейтинг ниже глобального среднего
)

Задача 3
Найди книги, опубликованные в течение последних двух лет, где количество страниц больше максимального рейтинга отзывов,
умноженного на 50. Используй аннотацию и F.
two_years_ago = timezone.now() - relativedelta(years=2)
BookG.objects.annotate(max_rate=Max('reviews__rating')).filter(Q(pages__gt=F('max_rate') * 50)) & Q(created_at__gt=two_year))

Задача 4
Выведи жанры, которые связаны с книгами, где хотя бы 30% отзывов имеют рейтинг ниже 2.
from django.db.models.functions import Round
genres = Genre.objects.annotate(count_books=Count('books'), reviews_abow_two=Count('books',
                    filter=Q(books__reviews__rating__lt=2)),
                    percent=ExpressionWrapper(F('reviews_abow_two') * 1.0 / F('count_books') * 100,
                    output_field=FloatField())).annotate(round_precent=Round('percent', 2)).filter(round_precent__gt=30)

Задача 5
Аннотируй жанры полем TopBookRating, которое будет содержать максимальный рейтинг книги из жанра, и выведи жанры,
где TopBookRating выше среднего рейтинга всех книг.
эту задачу ты и сам в другой беседе смог решить только в 2 запросса
avg_all_books_rating = BookG.objects.aggregate(avg_rating=Avg('reviews__rating'))['avg_rating']
Genre.objects.annotate(TopBookRating=Max('books__reviews__rating')).filter(TopBookRating__gt=avg_all_books_rating)

Задача 6
Добавь к авторам поле BooksWeight, которое будет суммой страниц всех их книг. Выведи только тех авторов, у которых
это значение превышает 10 000.
Author.objects.annotate(BooksWeight=Sum('books__pages')).filter(BooksWeight__gt=10000)

Задача 7
Найди книги, где количество отзывов с рейтингом 5 больше, чем количество отзывов с рейтингом 1. Исп. аннотацию и фильтры.
BookG.objects.annotate(reviews_five=Count('reviews', filter=Q(reviews__rating=5)), reviews_one=Count('reviews',
                                        filter=Q(reviews__rating=1))).filter(reviews_five__gt=F('reviews_one'))

Задача 8
Добавь к книгам поле OldOrRecent, которое будет показывать:
"Old", если книга создана больше 5 лет назад.
"Recent", если книга создана меньше 5 лет назад.
five_year = timezone.now() - relativedelta(years=5)
BookG.objects.annotate(OldOrRecent=Case(When(created_at__lt=five_year, then=Value('Old')),
                                  When(created_at__gt=five_year, then=Value('Recent')), output_field=CharField()))

Задача 9
Выведи авторов, у которых есть хотя бы одна книга, где количество отзывов меньше, чем количество страниц.
BookG.objects.annotate(rev_count=Count('reviews')).filter(rev_count__lt=F('pages'))

Задача 10
Добавь к книгам поле ReviewRateDifference, которое будет содержать разницу между максимальным и минимальным рейтингом
отзывов. Отфильтруй книги, у которых эта разница больше 2.
BookG.objects.annotate(max_rate=Max('reviews__rating'), min_rate=Min('reviews__rating'),
                                  ReviewRateDifference=ExpressionWrapper(F('max_rate') - F('min_rate'), output_field=IntegerField())).filter(ReviewRateDifference__gt=2)

Задача 11
Выведи жанры, у которых суммарное количество страниц книг больше среднего количества страниц всех книг.
avg_pages_all = BookG.objects.aggregate(avg_pages=Avg('pages'))['avg_pages']
Genre.objects.annotate(avg_pages_genre=Avg('books__pages')).filter(avg_pages_genre__gt=avg_pages_all)

Задача 12
Добавь к авторам поле AverageBookRating, которое будет средним рейтингом всех их книг. Найди авторов, у которых это
значение ниже среднего рейтинга всех книг всех авторов.
avg_all_rating = BookG.objects.aggregate(rate=Avg('reviews__rating'))['rate']
Author.objects.annotate(AverageBookRating=Avg('books__reviews__rating')).filter(AverageBookRating__lt=avg_all_rating)

Задача 13
Найди книги, которые были созданы в течение последнего месяца и имеют больше отзывов с рейтингом 5, чем книг, созданных
в тот же период, но с рейтингом 3.
month = timezone.now() - relativedelta(months=1)
BookG.objects.filter(created_at__gt=month).annotate(reviews_five_count=Count('reviews__rating',
                            filter=Q(reviews__rating=5)), reviews_three_count=Count('reviews',
                            filter=Q(reviews__rating=3))).filter(reviews_five_count__gt=F('reviews_three_count'))

Задача 14
Добавь к книгам поле GenreCount, которое будет показывать кол. жанров у книги, и найди книги, у которых больше 3 жанров.
BookG.objects.annotate(GenreCount=Count('genres')).filter(GenreCount__gt=3)


Задача 15
Найди авторов, чьи книги имеют хотя бы один отзыв с рейтингом 5 и опубликованы в феврале любого года.
Author.objects.filter(books__reviews__rating=5, books__created_at__month=2).distinct()

Задача 16
Добавь к книгам поле HasMixedReviews, которое будет True, если у книги есть отзывы с рейтингом 1 и 5 одновременно.
BookG.objects.annotate(HasMixedReviews=Case(When(Q(reviews__rating=1) & Q(reviews__rating=5), then=Value(True)),
                                                      default=Value(False), output_field=BooleanField())).distinct()

Задача 17
Выведи авторов, чьи книги в среднем имеют больше 10 отзывов. Используй аннотацию и фильтры.
тут неочень понятно толи в сумме книги должны иметь больше 10 отзывов толи каждая, предположим что каждая
Author.objects.annotate(count_books=Count('books'),
                                count_revs=Count('books__reviews')).filter(count_revs__gt=F('count_books') * 10)

Задача 18
Найди книги, которые опубликованы в течение посл. года и имеют в среднем больше 300 страниц на каждую жанровую категорию.
year = timezone.now() - relativedelta(years=1)
books = BookG.objects.filter(created_at__gt=year).annotate(all_genres=Count('genres'),
                                        pages_in_genres_all=Sum('genres__books__pages')) \


Задача 19

Добавь к жанрам поле LowRatedBooks, которое будет содержать количество книг с рейтингом ниже 3, и выведи жанры,
где LowRatedBooks превышает 5.
ты идумаешь в книгах есть поле рейтинг?

Задача 20
Найди книги, где разница между средней оценкой отзывов и их медианой больше 1. Используй аннотации и фильтры.
я незнаю что такое медианная оценка и как её высчитать...


book_descriptions = [
    "Эпическое путешествие по непокоренным вершинам, захватывающее и вдохновляющее.",
    "Глубокое исследование человеческих эмоций в условиях экстремальных обстоятельств.",
    "Простой и понятный подход к сложным жизненным вопросам и их решению.",
    "История любви, развернувшаяся на фоне суровых горных пейзажей.",
    "Отличная книга для любителей приключений и невообразимых испытаний.",
    "Герои преодолевают огромные трудности на пути к личной победе.",
    "Жизненные уроки, вдохновленные реальными событиями, полные неожиданных поворотов.",
    "Драматическая и вдохновляющая история, полная интересных поворотов сюжета.",
    "Захватывающее описание невероятных приключений на пути к достижению цели.",
    "Увлекательная и динамичная история с глубокими философскими подтекстами.",
    "Мудрость старых традиций, которые спасают героев от тяжелых испытаний.",
    "Книга, которая заставляет задуматься о жизни, смысле и личных целях."
]

niks = ['Pterodactel', 'Gor', 'Gibbon', 'Golden Teacher', 'Fantom', 'Ares']


def count(rev):
    ...:     return Reviews.objects.filter(book=rev.book, user=rev.user).count()

In [15]: for i in revs:
    ...:     i.count = count(i)
    ...:     cons(i.user.username, i.count)

 users = User.objects.all()

    ...:     if i.count > 1:
    ...:         while i.count > 1:
    ...:             user = choice(users)
    ...:             if not Review.objects.filter(book=i.book, user=user).exists():
    ...:                 i.user = user
    ...:                 i.save()
    ...:                 i.count = 1
    ...:                 cons(i.book, i.user)

# задача 2
# Составь запрос для нахождения жанров, в которых есть хотя бы одна книга с рейтингом ниже 2, но все остальные книги имеют рейтинг выше 4.
genres = Genre.objects.filter(books__reviews__rating__lt=2).annotate(all_books=Count('books'),
books_gt_4=Count('books', filter=Q(books__reviews__rating__gt=4))).filter(Q(books_gt_4=F('all_books') - 1))

# задача 3
# Выведи список авторов, у которых средний рейтинг всех книг выше глобального среднего рейтинга, но есть хотя бы одна книга с рейтингом ниже 2
glob_avg_rating = BookG.objects.aggregate(avg_all=Avg('reviews__rating'))['avg_all']
authors = Author.objects.filter(books__reviews__rating__lt=2).annotate(avg_book_rating=Avg('books__reviews__rating'))
                                                                          .filter(avg_book_rating__gt=glob_avg_rating)

# задача 4
# Найди книги, у которых средний рейтинг всех рецензий на книгу выше среднего рейтинга всех книг в жанре.
# у книг по 3 жанра...

# задача 5
# Выведи авторов, чьи книги в жанре "фэнтези" имеют лучший средний рейтинг по сравнению с книгами других жанров.
books_avg_not_fantazy = BookG.objects.exclude(genres__name__icontains='фэнтези').filter(author=OuterRef('pk'))
                                      .values('author').annotate(avg_rate=Avg('reviews__rating')).values('avg_rate')[:1]
authors = Author.objects.annotate(avg_fantazy=Avg('books__reviews__rating', filter=Q(books__title__icontains='фэнтези')),
                            avg_not_fantazy=Subquery(books_avg_not_fantazy)).filter(avg_fantazy__gt=F('avg_not_fantazy'))

# задача 6
# Составь запрос для нахождения авторов, у которых все книги имеют рейтинг ниже глобального среднего, но среди этих
книг есть хотя бы одна книга с рейтингом выше 4.
glob_avg_rating = BookG.objects.aggregate(avg_all=Avg('reviews__rating'))['avg_all']
authors = Author.objects.filter(books__reviews__rating__gt=4).annotate(total=Count('books'),
          low_glob=Count('books', filter=Q(books__reviews__rating__lt=glob_avg_rating))).filter(low_glob=F('total') - 1)

# задача 7
# Выведи список жанров, в которых средний рейтинг книг за последний год выше среднего рейтинга всех жанров за этот же период.
one_year = timezone.now() - relativedelta(years=1)
total_avg = Genre.objects.aggregate(total=Avg('books__reviews__rating', filter=Q(books__reviews__created_at__gt=one_year)))['total']
genres = Genre.objects.annotate(avg_rate=Avg('books__reviews__rating',
                                      filter=Q(books__reviews__created_at__gt=one_year))).filter(avg_rate__gt=total_avg)

# задача 8
# Найди книги, у которых количество рецензий больше 50 и средний рейтинг всех рецензий выше 4
books = BookG.objects.annotate(reviews_total=Count('reviews'), avg_rate=Avg('reviews__rating'))
                                                                          .filter(reviews_total__gt=50, avg_rate__gt=4)

# задача 9
# Составь запрос для нахождения жанров, в которых более 20% книг имеют рейтинг ниже 3
genres = Genre.objects.annotate(total_books=Count('books'), count_books_abowe_3=Count('books',
filter=Q(books__reviews__rating__lt=3)), percent_abowe_3=ExpressionWrapper((F('count_books_abowe_3') * 1.0) /
                        F('total_books') * 100, output_field=fields.IntegerField())).filter(percent_abowe_3__gt=20)

# задача 10
# Найди авторов, у которых все книги имеют рейтинг ниже глобального среднего рейтинга, но есть хотя бы одна книга с рейтингом выше 4.
glob_range = BookG.objects.aggregate(glob=Avg('reviews__rating'))['glob']
authors = Author.objects.filter(books__reviews__rating__gt=4).annotate(all_books=Count('books'),
books_lt_glob=Count('books', filter=Q(books__reviews__rating__lt=glob_range))).filter(books_lt_glob=F('all_books') - 1)

# задача 11
# Составь запрос для нахождения книг с количеством рецензий больше среднего для всех книг в базе данных.
avg_all_books_reviews = BookG.objects.annotate(avg_revs=Count('reviews')).aggregate(total=Avg('avg_revs'))['total']
books = BookG.objects.annotate(count_revs=Count('reviews')).filter(count_revs__gt=avg_all_books_reviews)


# задача 12
# Найди книги, у которых количество рецензий больше 10, но средний рейтинг всех рецензий ниже 3
 books = BookG.objects.annotate(rev_count=Count('reviews'), rev_avg=Avg('reviews__rating')).filter(rev_count__gt=10, rev_avg__lt=3)

# задача 13
# Выведи авторов, у которых средний рейтинг книг по жанрам отличается не более чем на 1 балл.
??? как это сделать за 1 запрос без цикла?

# задача 14
# Составь запрос для нахождения книг, где максимальный рейтинг среди всех рецензий выше 4, а средний рейтинг всех рецензий ниже 3
books = BookG.objects.annotate(max_rate=Max('reviews__rating'), avg_rate=Avg('reviews__rating')).filter(max_rate__gt=4, avg_rate__lt=3)

# задача 15
# Найди жанры, в которых есть хотя бы одна книга с рейтингом выше 4, но средний рейтинг всех книг в жанре ниже 3
genres = Genre.objects.filter(books__reviews__rating__gt=4).annotate(avg_books_rate=Avg('books__reviews__rating'))
                                                                                          .filter(avg_books_rate__lt=3)

# задача 16
# Выведи авторов, чьи книги имеют максимальный рейтинг среди всех книг в базе данных.
all_max_rate = BookG.objects.aggregate(mx_rate=Max('reviews__rating'))['mx_rate']
authors = Author.objects.filter(books__reviews__rating=all_max_rate)

# задача 17
# Составь запрос для нахождения жанров, в которых есть хотя бы одна книга с рейтингом ниже 3 и хотя бы одна книга с рейтингом выше 4.
genres = Genre.objects.filter(books__reviews__rating__lt=3).filter(books__reviews__rating__gt=4).distinct()

# задача 18
# Найди книги, которые имеют меньше 5 рецензий, но средний рейтинг всех рецензий выше 4.
books = BookG.objects.annotate(count_revs=Count('reviews'), avg_rate=Avg('reviews__rating')).filter(count_revs__lt=5, avg_rate__gt=4)

# задача 19
# Выведи жанры, в которых средний рейтинг книг выше 3, но у каждой книги в жанре есть хотя бы один отзыв с рейтингом ниже 2.
genres = Genre.objects.annotate(avg_rate=Avg('books__reviews__rating'), all_books=Count('books'), books_rate_below_2=
Count('books', filter=Q(books__reviews__rating__lt=2))).filter(Q(avg_rate__gt=3) & Q(all_books=F('books_rate_below_2')))

# задача 20
# Найди авторов, у которых все книги имеют рейтинг выше среднего для этого жанра.
для какого жанра? у меня на жанры связь мтм с книгами...

# Задача 1:
# Добавь к книгам поле Popularity, вычисляемое через Case и When, как раньше, но с дополнительным условием: если у
# книги нет рецензий, то присваиваем ей значение "Unknown".
bbooks = BookG.objects.annotate(avg_rate=Avg('reviews__rating'), total_revs=Count('reviews'), Popularity=
Case(When(Q(avg_rate__gt=4) & Q(total_revs__gt=50), then=Value('High')), When(Q(avg_rate__in=[3, 4]) &
Q(total_revs__range=[20, 50]), then=Value('Medium')), When(total_revs=0, then=Value('Unknown')),
                                                                      default=Value('Low'), output_field=CharField()))

Задача 2:
# Найди авторов, у которых хотя бы 1 книга имеет рейтинг выше среднего рейтинга всех книг, но все остальные книги имеют
# рейтинг ниже среднего рейтинга всех книг всех авторов.
# немного непонятно 1 книга имеет рейтинк выше среднего рейтинга этого автора? ну допустим так...
glob_avg = Author.objects.aggregate(total=Avg('books__reviews__rating'))['total']
authors = Author.objects.annotate(avg_rate=Avg('books__reviews__rating'), all_books=Count('books'),
count_books_abawe_glob=Count('books', filter=Q(books__reviews__rating__gt=glob_avg)))\
.filter(Q(books__reviews__rating__gt=F('avg_rate')) & Q(count_books_abawe_glob=F('all_books') - 1))

# Задача 3:
# Используя аннотации, вычисли средний рейтинг книги и общее количество рецензий по каждой книге, и выбери
# книги, у которых средний рейтинг больше 3 и количество рецензий больше 20.
books = BookG.objects.annotate(avg_rate=Avg('reviews__rating'), amount_revs=Count('reviews'))\

                                                                          .filter(avg_rate__gt=3, amount_revs__gt=20)
# Задача 4:
# Найди жанры, которые имеют хотя бы одну книгу с рейтингом ниже 2, и выведи жанры, где количество таких книг превышает 10.
genres = Genre.objects.filter(books__reviews__rating__lt=2).annotate(amount_books_below_2=Count('books',
                                            filter=Q(books__reviews__rating__lt=2))).filter(amount_books_below_2__gt=10)
"gpt4_review"."rating" < 2) AS "amount_books_below_2" FROM "gpt4_genre" LEFT OUTER JOIN "gpt4_bookgenre" ON ("gpt4_genre"."id" =
"gpt4_bookgenre"."genre_id") LEFT OUTER JOIN "gpt4_bookg" ON ("gpt4_bookgenre"."book_id" = "gpt4_bookg"."id") LEFT OUTER JOIN "gpt4_review" ON
("gpt4_bookg"."id" = "gpt4_review"."book_id") WHERE "gpt4_review"."rating" < 2 GROUP BY "gpt4_genre"."id" HAVING
COUNT("gpt4_bookgenre"."book_id") FILTER (WHERE ("gpt4_review"."rating" < 2)) > 10

# Задача 5:
# Для каждого жанра, аннотируй его количеством книг с рейтингом выше 4, и выведи жанры, где хотя бы 30% книг
# имеют рейтинг выше 4.
genres = Genre.objects.annotate(rate_abawe_4=Count('books', filter=Q(books__reviews__rating__gt=4)),
all_books=Count('books'), percent=ExpressionWrapper(F('rate_abawe_4') * 1.0 / F('all_books') * 100,
output_field=FloatField())).annotate(round_percent=Round('percent', 2)).filter(round_percent__gt=30)

# Задача 6: Добавь к авторам поле BooksWeight, которое будет суммой страниц всех их книг, и выведи тех авторов, у
# которых есть хотя бы 1 книга с рейтингом выше 3 и общее количество страниц всех книг автора больше 10,000.
authors = Author.objects.filter(books__reviews__rating__gt=3).annotate(BooksWeight=Sum('books__pages'))\
                                                                                          .filter(BooksWeight__gt=10000)

# Задача 7: Используя аннотацию, создай поле, которое будет показывать, сколько книг с рейтингом выше 3 написал каждый
# автор, и выбери авторов, у которых количество таких книг больше 3.
authors = Author.objects.annotate(rate_above_3=Count('books__reviews__rating', filter=Q(books__reviews__rating__gt=3)))\
                                                                                             .filter(rate_above_3__gt=3)

# Задача 8: Найди книги, которые опубликованы в течение последних 3 лет, и выведи те, у которых разница между
# максимальным и минимальным рейтингом отзывов больше 3.
three_years = timezone.now() - relativedelta(years=3)
books = BookG.objects.filter(created_at__gt=three_years).annotate(max_rate=Max('reviews__rating'),
min_rate=Min('reviews__rating'), difference=ExpressionWrapper(F('max_rate') - F('min_rate'),
                                                                  output_field=IntegerField())).filter(difference__gt=3)


                                      # В ШПАРГАЛКИ !!!!!!!!!!!!!!!!!!!!!!
# Задача 9: Найди авторов, у которых есть хотя бы одна книга с количеством отзывов меньше, чем количество страниц книги,
# но при этом средний рейтинг их книг выше 4.
# Exists, Django создаёт SQL-запрос, который проверяет только наличие данных, не загружая их в память.
revs_les_then_pages = BookG.objects.filter(author=OuterRef('pk')).values('author')\
                                              .annotate(count_revs=Count('reviews')).filter(pages__ gt=F('count_revs'))
ats = Author.objects.annotate(avg_rate=Avg('books__reviews__rating'), more_pages=Exists(revs_les_then_pages))\
                                                                                .filter(avg_rate__gt=4, more_pages=True)


# Задача 10: Добавь к книгам поле ReviewRateDifference, которое будет содержать разницу между максимальным и минимальным
# рейтингом отзывов, и выбери книги, у которых эта разница больше 3, а средний рейтинг выше 3.
bk = BookG.objects.annotate(max_rate=Max('reviews__rating'), min_rate=Min('reviews__rating'),
                  avg_rate=Avg('reviews__rating'), ReviewRateDifference=ExpressionWrapper(F('max_rate') - F('min_rate'),
                                        output_field=IntegerField())).filter(ReviewRateDifference__gt=3, avg_rate__gt=3)

# Задача 11: Используя аннотацию, создай поле, которое будет показывать количество жанров, к которым принадлежит каждая
# книга, и выбери книги, которые принадлежат более 3 жанрам, при этом количество страниц книги больше среднего
# количества страниц книг всех жанров.
avg_global_count = Genre.objects.aggregate(glob=Avg('books__pages'))['glob']
bks = BookG.objects.annotate(count_genres=Count('genres')).filter(count_genres__gt=3, pages__gt=avg_global_count)

# Задача 12: Для каждого автора аннотируй средний рейтинг всех его книг и выбери авторов, у которых средний рейтинг
# всех книг выше среднего рейтинга всех книг всех авторов, но при этом хотя бы одна из их книг имеет рейтинг ниже 2.
total_avg_rate = Author.objects.aggregate(rate=Avg('books__reviews__rating'))['rate']
atrs = Author.objects.filter(books__reviews__rating__lt=2).annotate(avg_rate=Avg('books__reviews__rating'))\
                                                                                    .filter(avg_rate__gt=total_avg_rate)

# Задача 13: Добавь к книгам поле IsTrending, которое будет True, если книга опубликована в последние 6 месяцев и имеет
# больше 100 отзывов с рейтингом 5. Выведи книги, которые удовлетворяют этим условиям.
six_month = timezone.now() - relativedelta(months=6)
bs = BookG.objects.annotate(count_rate_5=Count('reviews__rating', filter=Q(reviews__rating=5)),
          IsTrending=Case(When(count_rate_5__gt=100, created_at__gt=six_month, then=Value(True)), default=Value(False),
                                                                  output_field=BooleanField())).filter(IsTrending=True)

# Задача 14: Выведи жанры, у которых есть хотя бы одна книга с рейтингом ниже 2, и среди этих жанров выбери те, где
# средний рейтинг книг выше 3.
gen = Genre.objects.filter(books__reviews__rating__lt=2).annotate(avg_rate=Avg('books__reviews__rating'))\
                                                                                                .filter(avg_rate__gt=3)

# Задача 15: Найди книги, опубликованные в течение последних двух лет, где количество страниц больше максимального
# рейтинга отзывов, умноженного на 100, и при этом у книги больше 20 рецензий с рейтингом выше 4.
two_years = timezone.now() - relativedelta(years=2)
bks = BookG.objects.filter(created_at__gt=two_years).annotate(max_rate=Max('reviews__rating'), revs_above_4=
    Count('reviews', filter=Q(reviews__rating__gt=4))).filter(Q(pages__gt=F('max_rate') * 100) & Q(revs_above_4__gt=20))

# Задача 16: Добавь к книгам поле HasMixedReviews, которое будет True, если у книги есть отзывы с рейтингом 1 и 5
# одновременно. Найди книги, у которых есть такие отзывы, и количество рецензий с рейтингом 5 превышает количество
# рецензий с рейтингом 1.
bks = BookG.objects.annotate(rate_5=Count('reviews__rating', filter=Q(reviews__rating=5)),
rate_1=Count('reviews__rating', filter=Q(reviews__rating=1)), HasMixedReviews=Case(When(rate_1__isnull=False,
rate_5__isnull=False, then=Value(True)), default=Value(False), output_field=BooleanField())).filter(rate_5__gt=F('rate_1'))

# Задача 17: Для каждого автора вычисли суммарное количество страниц всех его книг и аннотируй поле PagesPerBook,
# которое будет содержать среднее количество страниц на книгу. Выведи авторов, у которых это значение больше 500.
authors = Author.objects.annotate(total_pages=Sum('books__pages'), PagesPerBook=Avg('books__pages')).filter(PagesPerBook__gt=500)

# Задача 18: Найди книги, которые были созданы в течение последнего месяца и имеют больше отзывов с рейтингом 5, чем
# книг, созданных в тот же период, но с рейтингом 3. Выведи книги с наибольшим количеством рецензий с рейтингом 5.
month = timezone.now() - relativedelta(days=1)
bs = BookG.objects.filter(created_at__gt=month, reviews__rating=3).count()
bbks = BookG.objects.filter(created_at__gt=month).annotate(revs_5=Count('reviews__rating',
                                            filter=Q(reviews__rating=5))).filter(revs_5__gt=bs).order_by('-revs_5')[:3]

# Задача 19: Добавь к жанрам поле TopBookRating, которое будет содержать максимальный рейтинг книги в жанре. Выведи
# жанры, у которых TopBookRating больше 4.
ge = Genre.objects.annotate(TopBookRating=Max('books__reviews__rating')).filter(TopBookRating__gt=4)


# Задача 20: Для каждого автора, у которого есть хотя бы 1 книга с рейтингом выше 4, вычисли среднее количество рецензий
# на книгу, и выбери авторов, у которых это значение больше 10.
at = Author.objects.filter(books__reviews__rating__gt=4).annotate(avg_revs=Avg('books__reviews')).filter(avg_revs__gt=10)
